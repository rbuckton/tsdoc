const fs = require('fs');
const path = require('path');

function groupBySection(tests) {
    const groups = new Map();
    const sections = [];
    for (const test of tests) {
        let section = groups.get(test.section);
        if (!section) {
            section = [];
            groups.set(test.section, section);
            sections.push([test.section, section]);
        }
        section.push(test);
    }
    return sections;
}

function makeRelative(from, to) {
    to = path.resolve(__dirname, to);
    let relative = path.relative(from, to);
    if (!path.isAbsolute(relative) && relative.charAt(0) !== '.') {
        relative = './' + relative;
    }
    return relative.replace(/\\/g, '/');
}

let gfm = false;
const args = process.argv.slice(2).filter(s => {
    if (s === '--gfm') {
        gfm = true;
        return false;
    }
    return true;
});

if (args.length < 2) {
    console.log('usage: node generateTests.js <spec.json> <spec.ts> [--gfm]');
    process.exit(1);
}

const [specJsonFile, specTsFile] = args;
const resolvedSpecJsonFile = path.resolve(specJsonFile);
const resolvedSpecTsFile = path.resolve(specTsFile);
const allTests = require(resolvedSpecJsonFile);

const BlockParser = makeRelative(path.dirname(resolvedSpecTsFile), '../src/beta/parser/BlockParser');
const Document = makeRelative(path.dirname(resolvedSpecTsFile), '../src/beta/nodes/Document');
const HtmlEmitter = makeRelative(path.dirname(resolvedSpecTsFile), '../src/beta/emitters/HtmlEmitter');
const serializers = makeRelative(path.dirname(resolvedSpecTsFile), '../src/beta/parser/__tests__/serializers');

const lines = [
    `// This file was autogenerated by ~/scripts/generateTests.js and should not be modified.`,
    ``,
    `import { BlockParser } from ${JSON.stringify(BlockParser)};`,
    `import { Document } from ${JSON.stringify(Document)};`,
    `import { SnapshotSerializer } from ${JSON.stringify(serializers)};`,
    `import { HtmlEmitter } from ${JSON.stringify(HtmlEmitter)};`,
    ``,
    'expect.addSnapshotSerializer(SnapshotSerializer.serializer);',
    ``,
    `function parse(text: string): Document {`,
    `    const parser: BlockParser = new BlockParser(text, undefined, ${gfm});`,
    `    return parser.parse();`,
    `}`,
    ``,
    `function emit(document: Document): string {`,
    ...(gfm ? [
        `    const emitter: HtmlEmitter = new HtmlEmitter(`,
        `        tagName => !/^(title|textarea|style|xmp|iframe|noembed|noframes|script|plaintext)$/i.test(tagName)`,
        `    );`,
    ] : [
        `    const emitter: HtmlEmitter = new HtmlEmitter();`,
    ]),
    `    emitter.emit(document);`,
    `    return emitter.toString();`,
    `}`,
    ``,
];

const url = gfm ? 'https://github.github.com/gfm/' : 'https://spec.commonmark.org/0.29/';
for (const [section, tests] of groupBySection(allTests)) {
    const describe =
        section.only ? 'describe.only' :
        section.skip ? 'describe.skip' :
        'describe';
    lines.push(`${describe}(${JSON.stringify(section)}, () => {`);
    for (const test of tests) {
        const name =
            test.custom ? test.custom :
            test.example ? `<${url}#example-${test.example}>` :
            undefined;
        if (name === undefined) continue;
        const it =
            test.only ? 'it.only' :
            test.skip ? 'it.skip' :
            'it'
        lines.push(`    ${it}(${JSON.stringify(name)}, () => {`);
        lines.push(`        const markdown: string = ${JSON.stringify(test.markdown)};`);
        lines.push(`        const expected: string = ${JSON.stringify(test.html)};`);
        lines.push(`        const document: Document = parse(markdown);`);
        lines.push(`        const actual: string = emit(document);`);
        lines.push(`        expect(actual).toBe(expected);`);
        lines.push(`        expect(document).toMatchSnapshot();`);
        lines.push(`    });`);
    }
    lines.push(`});`);
}

fs.writeFileSync(path.resolve(specTsFile), lines.join('\n'), 'utf8');